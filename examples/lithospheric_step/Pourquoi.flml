<?xml version='1.0' encoding='utf-8'?>
<fluidity_options>
  <simulation_name>
    <string_value lines="1">Pourquoi</string_value>
  </simulation_name>
  <problem_type>
    <string_value lines="1">multimaterial</string_value>
  </problem_type>
  <geometry>
    <dimension>
      <integer_value rank="0">2</integer_value>
    </dimension>
    <mesh name="CoordinateMesh">
      <from_file file_name="mesh/Mesh">
        <format name="gmsh"/>
        <stat>
          <include_in_stat/>
        </stat>
      </from_file>
    </mesh>
    <mesh name="VelocityMesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <mesh_shape>
          <polynomial_degree>
            <integer_value rank="0">2</integer_value>
          </polynomial_degree>
        </mesh_shape>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <quadrature>
      <degree>
        <integer_value rank="0">5</integer_value>
      </degree>
    </quadrature>
  </geometry>
  <io>
    <dump_format>
      <string_value>vtk</string_value>
    </dump_format>
    <dump_period>
      <constant>
        <real_value rank="0">3.156e13</real_value>
      </constant>
    </dump_period>
    <output_mesh name="CoordinateMesh"/>
    <stat/>
  </io>
  <particles>
    <particle_group name="Melt">
      <particle_io>
        <dump_period>
          <constant>
            <real_value rank="0">3.156e13</real_value>
          </constant>
        </dump_period>
      </particle_io>
      <particle_subgroup name="SubMelt">
        <initial_position>
          <python>
            <string_value type="code" language="python" lines="20">def val(t):
    from numpy import vstack
    from numpy.random import default_rng
    return vstack((default_rng(0).uniform([1e6, 7.5e5], [1.3e6, 1e6], (5_000, 2)),
                   default_rng(0).uniform([2.7e6, 7.5e5], [3e6, 1e6], (5_000, 2))))</string_value>
          </python>
        </initial_position>
        <attributes>
          <scalar_attribute name="Time">
            <python>
              <string_value type="code" language="python" lines="20">def val(X, t, dt):
    return t / 8.64e4 / 365.25 / 1e6</string_value>
            </python>
          </scalar_attribute>
          <scalar_attribute_array name="Katz">
            <dimension>
              <integer_value rank="0">6</integer_value>
            </dimension>
            <python_fields>
              <string_value type="code" language="python" lines="20">def val(X, t, dt, fields, n):
    from numpy import clip

    from Constants import adGra, alpha, domainDim, g, rhoMantle, X_H2O_bulk
    from Melt import Katz

    depth = clip(domainDim[1] - X[1], 0, domainDim[1])
    presGPa = rhoMantle * g * depth / 1e9
    temp = fields['Temperature'] + adGra * depth

    if t == 0:
        F = Katz().KatzPT(presGPa, temp,
                          inputConst={'X_H2O_bulk': X_H2O_bulk, 'M_cpx': 0.18,
                                      'r0': 0.94, 'r1': -0.1, 'B1': 1520 + 273.15,
                                      'beta2': 1.2})
        return (F, F, 0, presGPa, temp, 0)

    sol = Katz().KatzPTF(
        fields['old%Katz'][3], presGPa, fields['old%Katz'][4],
        fields['old%Katz'][0], (temp - fields['old%Katz'][4])
        / (presGPa - fields['old%Katz'][3]),
        inputConst={'X_H2O_bulk': X_H2O_bulk, 'c_P': 1187, 'deltaS': 407,
                    'M_cpx': 0.18, 'r0': 0.94, 'r1': -0.1, 'B1': 1520 + 273.15,
                    'beta2': 1.2, 'alpha_s': alpha, 'rho_s': rhoMantle})

    T, F = sol(presGPa)
    F = 0 if F &lt; 0 else F
    if F &gt; fields['old%Katz'][1]:
        mRate = (F - fields['old%Katz'][1]) / dt * 8.64e4 * 365.25 * 1e6
        tempSource = (T - temp) / dt
        return (F, F, mRate, presGPa, T, tempSource)
    else:
        return (F, fields['old%Katz'][1], 0, presGPa, temp, 0)</string_value>
              <store_old_attribute/>
            </python_fields>
          </scalar_attribute_array>
        </attributes>
      </particle_subgroup>
    </particle_group>
    <moving_outside_domain>
      <delete_outside_domain/>
    </moving_outside_domain>
    <lagrangian_timestepping>
      <subcycles>
        <integer_value rank="0">3</integer_value>
      </subcycles>
      <search_tolerance>
        <real_value rank="0">1e-12</real_value>
      </search_tolerance>
      <rk4_guided_search/>
    </lagrangian_timestepping>
  </particles>
  <timestepping>
    <current_time>
      <real_value rank="0">0.</real_value>
    </current_time>
    <timestep>
      <real_value rank="0">1e12</real_value>
    </timestep>
    <finish_time>
      <real_value rank="0">6.32e14</real_value>
    </finish_time>
    <adaptive_timestep>
      <requested_cfl>
        <real_value rank="0">3</real_value>
      </requested_cfl>
      <courant_number name="ControlVolumeCFLNumber">
        <mesh name="CoordinateMesh"/>
      </courant_number>
      <maximum_timestep>
        <real_value rank="0">1.262e13</real_value>
      </maximum_timestep>
      <increase_tolerance>
        <real_value rank="0">1.1</real_value>
      </increase_tolerance>
    </adaptive_timestep>
  </timestepping>
  <physical_parameters>
    <gravity>
      <magnitude>
        <real_value rank="0">9.8</real_value>
      </magnitude>
      <vector_field name="GravityDirection" rank="1">
        <prescribed>
          <mesh name="CoordinateMesh"/>
          <value name="WholeMesh">
            <constant>
              <real_value rank="1" dim1="dim" shape="2">0 -1</real_value>
            </constant>
          </value>
          <output/>
          <stat>
            <include_in_stat/>
          </stat>
          <detectors>
            <exclude_from_detectors/>
          </detectors>
          <particles>
            <exclude_from_particles/>
          </particles>
        </prescribed>
      </vector_field>
    </gravity>
  </physical_parameters>
  <material_phase name="EverythingExcept">
    <equation_of_state>
      <fluids>
        <linear>
          <reference_density>
            <real_value rank="0">3370</real_value>
          </reference_density>
          <temperature_dependency>
            <reference_temperature>
              <real_value rank="0">290</real_value>
            </reference_temperature>
            <thermal_expansion_coefficient>
              <real_value rank="0">3e-5</real_value>
            </thermal_expansion_coefficient>
          </temperature_dependency>
          <subtract_out_hydrostatic_level/>
        </linear>
      </fluids>
    </equation_of_state>
    <scalar_field rank="0" name="Pressure">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <remove_stabilisation_term/>
            <integrate_continuity_by_parts/>
            <test_continuity_with_cv_dual/>
          </continuous_galerkin>
        </spatial_discretisation>
        <scheme>
          <poisson_pressure_solution>
            <string_value lines="1">never</string_value>
          </poisson_pressure_solution>
          <use_projection_method>
            <full_schur_complement>
              <inner_matrix name="FullMomentumMatrix"/>
              <preconditioner_matrix name="ScaledPressureMassMatrix"/>
            </full_schur_complement>
          </use_projection_method>
        </scheme>
        <solver>
          <iterative_method name="fgmres"/>
          <preconditioner name="ksp">
            <solver>
              <iterative_method name="cg"/>
              <preconditioner name="sor"/>
              <relative_error>
                <real_value rank="0">1e-7</real_value>
              </relative_error>
              <max_iterations>
                <integer_value rank="0">1000</integer_value>
              </max_iterations>
              <never_ignore_solver_failures/>
              <diagnostics>
                <monitors/>
              </diagnostics>
            </solver>
          </preconditioner>
          <relative_error>
            <real_value rank="0">1e-5</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <remove_null_space/>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </diagnostics>
        </solver>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <exclude_from_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field rank="0" name="Density">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <exclude_from_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <vector_field rank="1" name="Velocity">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <equation name="LinearMomentum"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <mass_terms>
              <exclude_mass_terms/>
            </mass_terms>
            <advection_terms>
              <exclude_advection_terms/>
            </advection_terms>
            <stress_terms>
              <partial_stress_form/>
            </stress_terms>
            <buoyancy/>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">1</real_value>
          </theta>
          <relaxation>
            <real_value rank="0">1</real_value>
          </relaxation>
        </temporal_discretisation>
        <solver>
          <iterative_method name="cg"/>
          <preconditioner name="gamg"/>
          <relative_error>
            <real_value rank="0">1e-6</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <multigrid_near_null_space>
            <all_components/>
            <all_rotations/>
          </multigrid_near_null_space>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <constant>
            <real_value rank="1" dim1="dim" shape="2">0 0</real_value>
          </constant>
        </initial_condition>
        <boundary_conditions name="Top">
          <surface_ids>
            <integer_value rank="1" shape="1">1</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <y_component>
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </y_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <boundary_conditions name="Bottom">
          <surface_ids>
            <integer_value rank="1" shape="1">4</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <x_component>
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </x_component>
              <y_component>
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </y_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <boundary_conditions name="Sides">
          <surface_ids>
            <integer_value rank="1" shape="4">2 3 5 6</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <align_bc_with_cartesian>
              <x_component>
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </x_component>
            </align_bc_with_cartesian>
          </type>
        </boundary_conditions>
        <tensor_field name="Viscosity" rank="2">
          <diagnostic>
            <mesh name="CoordinateMesh"/>
            <algorithm name="bulk_viscosity" material_phase_support="multiple" depends="MaterialViscosity">
              <mean name="harmonic"/>
            </algorithm>
            <output/>
            <stat>
              <include_in_stat/>
            </stat>
            <particles>
              <exclude_from_particles/>
            </particles>
          </diagnostic>
        </tensor_field>
        <output/>
        <stat>
          <include_in_stat/>
          <previous_time_step>
            <exclude_from_stat/>
          </previous_time_step>
          <nonlinear_field>
            <exclude_from_stat/>
          </nonlinear_field>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <adaptivity_options>
          <absolute_measure>
            <vector_field rank="1" name="InterpolationErrorBound">
              <prescribed>
                <value name="WholeMesh">
                  <constant>
                    <real_value rank="1" dim1="dim" shape="2">1e-12 1e-12</real_value>
                  </constant>
                </value>
                <output/>
                <stat>
                  <include_in_stat/>
                </stat>
                <detectors>
                  <exclude_from_detectors/>
                </detectors>
                <particles>
                  <exclude_from_particles/>
                </particles>
              </prescribed>
            </vector_field>
          </absolute_measure>
        </adaptivity_options>
        <consistent_interpolation/>
      </prognostic>
    </vector_field>
    <scalar_field rank="0" name="MaterialVolumeFraction">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <equation name="AdvectionDiffusion"/>
        <spatial_discretisation>
          <control_volumes>
            <face_value name="HyperC">
              <project_upwind_value_from_point>
                <bound_projected_value_locally/>
                <store_upwind_elements/>
              </project_upwind_value_from_point>
              <courant_number name="ControlVolumeCFLNumber"/>
            </face_value>
            <diffusion_scheme name="ElementGradient"/>
          </control_volumes>
          <conservative_advection>
            <real_value rank="0">0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">0</real_value>
          </theta>
          <control_volumes>
            <maximum_courant_number_per_subcycle>
              <real_value rank="0">0.5</real_value>
              <courant_number name="ControlVolumeCFLNumber"/>
            </maximum_courant_number_per_subcycle>
            <pivot_theta>
              <real_value rank="0">0</real_value>
            </pivot_theta>
          </control_volumes>
        </temporal_discretisation>
        <explicit/>
        <initial_condition name="WholeMesh">
          <python>
            <string_value type="code" language="python" lines="20">def val(X, t):
    from numpy import clip
    from Constants import conDepth, domainDim, stepLoc
    from IniTemp import func

    depth = clip(domainDim[1] - X[1], 0, domainDim[1])
    if depth &gt; conDepth:
        return 1
    elif X[0] &lt; stepLoc[0] or X[0] &gt; stepLoc[1]:
        return 1
    elif func(X) &lt;= 1595:
        return 0
    else:
        return 1</string_value>
          </python>
        </initial_condition>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <galerkin_projection>
          <continuous>
            <bounded name="Diffuse">
              <boundedness_iterations>
                <integer_value rank="0">1000</integer_value>
                <tolerance>
                  <real_value rank="0">1e-7</real_value>
                </tolerance>
              </boundedness_iterations>
              <bounds>
                <upper_bound>
                  <real_value rank="0">1</real_value>
                  <coupled/>
                </upper_bound>
                <lower_bound>
                  <real_value rank="0">0</real_value>
                </lower_bound>
              </bounds>
              <repair_deviations>
                <tolerance>
                  <real_value rank="0">1e-6</real_value>
                </tolerance>
              </repair_deviations>
            </bounded>
            <solver>
              <iterative_method name="fgmres"/>
              <preconditioner name="gamg"/>
              <relative_error>
                <real_value rank="0">1e-7</real_value>
              </relative_error>
              <max_iterations>
                <integer_value rank="0">1000</integer_value>
              </max_iterations>
              <never_ignore_solver_failures/>
              <diagnostics>
                <monitors/>
              </diagnostics>
            </solver>
          </continuous>
        </galerkin_projection>
        <priority>
          <integer_value rank="0">100</integer_value>
        </priority>
        <cap_values>
          <upper_cap>
            <real_value rank="0">1</real_value>
          </upper_cap>
          <lower_cap>
            <real_value rank="0">0</real_value>
          </lower_cap>
        </cap_values>
      </prognostic>
    </scalar_field>
    <scalar_field rank="0" name="Temperature">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <equation name="AdvectionDiffusion"/>
        <spatial_discretisation>
          <control_volumes>
            <mass_terms/>
            <face_value name="FiniteElement">
              <limit_face_value>
                <limiter name="Ultimate">
                  <courant_number name="ControlVolumeCFLNumber"/>
                  <project_upwind_value_from_point>
                    <bound_projected_value_locally/>
                    <store_upwind_elements>
                      <store_upwind_quadrature/>
                    </store_upwind_elements>
                  </project_upwind_value_from_point>
                </limiter>
              </limit_face_value>
            </face_value>
            <diffusion_scheme name="ElementGradient"/>
          </control_volumes>
          <conservative_advection>
            <real_value rank="0">0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">0.5</real_value>
          </theta>
          <control_volumes>
            <maximum_courant_number_per_subcycle>
              <real_value rank="0">0.5</real_value>
              <courant_number name="ControlVolumeCFLNumber"/>
            </maximum_courant_number_per_subcycle>
          </control_volumes>
        </temporal_discretisation>
        <solver>
          <iterative_method name="gmres">
            <restart>
              <integer_value rank="0">30</integer_value>
            </restart>
          </iterative_method>
          <preconditioner name="sor"/>
          <relative_error>
            <real_value rank="0">1e-7</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <python>
            <string_value type="code" language="python" lines="20">def val(X, t):
    from IniTemp import func
    return func(X)</string_value>
          </python>
        </initial_condition>
        <boundary_conditions name="Top">
          <surface_ids>
            <integer_value rank="1" shape="1">1</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <python>
              <string_value type="code" language="python" lines="20">def val(X,t):
    from Constants import surfTemp
    return surfTemp</string_value>
            </python>
          </type>
        </boundary_conditions>
        <boundary_conditions name="Bottom">
          <surface_ids>
            <integer_value rank="1" shape="1">4</integer_value>
          </surface_ids>
          <type name="dirichlet">
            <python>
              <string_value type="code" language="python" lines="20">def val(X,t):
    from Constants import mantTemp
    return mantTemp</string_value>
            </python>
          </type>
        </boundary_conditions>
        <tensor_field name="Diffusivity" rank="2">
          <prescribed>
            <value name="WholeMesh">
              <isotropic>
                <python>
                  <string_value type="code" language="python" lines="20">def val(X, t):
    from Constants import kappa
    return kappa</string_value>
                </python>
              </isotropic>
            </value>
            <output/>
            <particles>
              <exclude_from_particles/>
            </particles>
          </prescribed>
        </tensor_field>
        <scalar_field name="Source" rank="0">
          <diagnostic>
            <algorithm name="scalar_python_diagnostic" material_phase_support="single">
              <string_value type="code" language="python" lines="20">tempSource = state.scalar_fields['SourceFromParticles']
assert(tempSource.node_count == field.node_count)

for i in range(field.node_count):
    field.set(i, tempSource.node_val(i))</string_value>
              <depends>
                <string_value lines="1">SourceFromParticles</string_value>
              </depends>
            </algorithm>
            <output/>
            <stat/>
            <detectors>
              <include_in_detectors/>
            </detectors>
            <particles>
              <exclude_from_particles/>
            </particles>
          </diagnostic>
        </scalar_field>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <include_in_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <adaptivity_options>
          <absolute_measure>
            <scalar_field rank="0" name="InterpolationErrorBound">
              <prescribed>
                <value name="WholeMesh">
                  <constant>
                    <real_value rank="0">2</real_value>
                  </constant>
                </value>
                <output/>
                <stat/>
                <detectors>
                  <exclude_from_detectors/>
                </detectors>
                <particles>
                  <exclude_from_particles/>
                </particles>
              </prescribed>
            </scalar_field>
          </absolute_measure>
        </adaptivity_options>
        <consistent_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field rank="0" name="DynamicTopography">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value type="code" language="python" lines="20">from Constants import g, rhoMantle

pres = state.scalar_fields['Pressure']
visc = state.tensor_fields['Viscosity']
sr = state.tensor_fields['StrainRate']

assert(pres.node_count == field.node_count)
assert(visc.node_count == field.node_count)
assert(sr.node_count == field.node_count)

for i in range(field.node_count):
    field.set(i, (pres.node_val(i) - 2 * visc.node_val(i)[1, 1]
                  * sr.node_val(i)[1, 1]) / rhoMantle / g)</string_value>
          <depends>
            <string_value lines="1">StrainRate</string_value>
          </depends>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field rank="0" name="SourceFromParticles">
      <diagnostic>
        <algorithm name="from_particles" material_phase_support="multiple">
          <particle_group name="Melt">
            <particle_attribute_array name="Katz">
              <attribute_index>
                <integer_value rank="0">6</integer_value>
              </attribute_index>
            </particle_attribute_array>
          </particle_group>
          <interpolation>
            <weighted_distance/>
          </interpolation>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </diagnostic>
    </scalar_field>
    <scalar_field rank="0" name="DynamicTopographyAverageRemoved">
      <diagnostic>
        <algorithm name="subtract_surface_average" material_phase_support="single" source_field_name="DynamicTopography" source_field_type="scalar">
          <surface_ids>
            <integer_value rank="1" shape="1">1</integer_value>
          </surface_ids>
        </algorithm>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <tensor_field rank="2" name="StrainRate">
      <diagnostic>
        <algorithm name="strain_rate" material_phase_support="single " source_field_name="Velocity" source_field_type="vector"/>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <particles>
          <exclude_from_particles/>
        </particles>
      </diagnostic>
    </tensor_field>
    <tensor_field rank="2" name="MaterialViscosity">
      <diagnostic>
        <mesh name="CoordinateMesh"/>
        <algorithm name="tensor_python_diagnostic" material_phase_support="single">
          <string_value type="code" language="python" lines="20">from numpy import clip, empty, exp
from Constants import a0, a1, a2, adGra, domainDim, e0, e1, e2, g, lowMtl, muMax, muMin, R, r0, r1, r2, rhoMantle, v0, v1, v2

Temp = state.scalar_fields["Temperature"]
X = state.vector_fields["Coordinate"]

assert(Temp.node_count == field.node_count)
assert(X.node_count == field.node_count)

visc = empty((2, 2))

for i in range(field.node_count):
    depth = clip(domainDim[1] - X.node_val(i)[1], 0, domainDim[1])
    pres = rhoMantle * g * depth
    adTemp = Temp.node_val(i) + adGra * depth
    if depth &lt; lowMtl:
        water = 800
        mu = 1 / (a0 * water ** r0 * exp(-(e0 + pres * v0) / R / adTemp) + a1 * water ** r1 * exp(-(e1 + pres * v1) / R / adTemp))
    else:
        water = 200
        mu = 1 / (a2 * water ** r2 * exp(-(e2 + pres * v2) / R / adTemp) + a2 * water ** r2 * exp(-(e2 + pres * v2) / R / adTemp))
    mu = clip(mu, muMin, muMax)
    visc[:] = mu
    field.set(i, visc)</string_value>
          <depends>
            <string_value lines="1">Temperature</string_value>
          </depends>
        </algorithm>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <particles>
          <exclude_from_particles/>
        </particles>
      </diagnostic>
    </tensor_field>
  </material_phase>
  <material_phase name="Craton">
    <equation_of_state>
      <fluids>
        <linear>
          <reference_density>
            <real_value rank="0">3300</real_value>
          </reference_density>
          <temperature_dependency>
            <reference_temperature>
              <real_value rank="0">290</real_value>
            </reference_temperature>
            <thermal_expansion_coefficient>
              <real_value rank="0">3e-5</real_value>
            </thermal_expansion_coefficient>
          </temperature_dependency>
        </linear>
      </fluids>
    </equation_of_state>
    <vector_field rank="1" name="Velocity">
      <aliased material_phase_name="EverythingExcept" field_name="Velocity"/>
    </vector_field>
    <scalar_field rank="0" name="MaterialVolumeFraction">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="CoordinateMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <adaptivity_options>
          <absolute_measure>
            <scalar_field rank="0" name="InterpolationErrorBound">
              <prescribed>
                <value name="WholeMesh">
                  <constant>
                    <real_value rank="0">0.1</real_value>
                  </constant>
                </value>
                <output/>
                <stat/>
                <detectors>
                  <exclude_from_detectors/>
                </detectors>
                <particles>
                  <exclude_from_particles/>
                </particles>
              </prescribed>
            </scalar_field>
          </absolute_measure>
        </adaptivity_options>
        <cap_values>
          <upper_cap>
            <real_value rank="0">1</real_value>
          </upper_cap>
          <lower_cap>
            <real_value rank="0">0</real_value>
          </lower_cap>
        </cap_values>
      </diagnostic>
    </scalar_field>
    <scalar_field rank="0" name="Temperature">
      <aliased material_phase_name="EverythingExcept" field_name="Temperature"/>
    </scalar_field>
    <tensor_field rank="2" name="MaterialViscosity">
      <diagnostic>
        <mesh name="CoordinateMesh"/>
        <algorithm name="tensor_python_diagnostic" material_phase_support="single">
          <string_value type="code" language="python" lines="20">from numpy import clip, empty, exp
from Constants import a0, a1, a2, adGra, domainDim, e0, e1, e2, g, lowMtl, muMax, muMin, R, r0, r1, r2, rhoCraton, rhoCrust, v0, v1, v2

Temp = state.scalar_fields["Temperature"]
X = state.vector_fields["Coordinate"]

assert(Temp.node_count == field.node_count)
assert(X.node_count == field.node_count)

visc = empty((2, 2))

for i in range(field.node_count):
    depth = clip(domainDim[1] - X.node_val(i)[1], 0, domainDim[1])
    pres = g * (rhoCrust * 4.1e4 + rhoCraton * (depth - 4.1e4))
    adTemp = Temp.node_val(i) + adGra * depth
    if depth &lt; lowMtl:
        water = 800
        mu = 1 / (a0 * water ** r0 * exp(-(e0 + pres * v0) / R / adTemp) + a1 * water ** r1 * exp(-(e1 + pres * v1) / R / adTemp))
    else:
        water = 200
        mu = 1 / (a2 * water ** r2 * exp(-(e2 + pres * v2) / R / adTemp) + a2 * water ** r2 * exp(-(e2 + pres * v2) / R / adTemp))
    mu = clip(1e2 * mu, muMin, muMax)
    visc[:] = mu
    field.set(i, visc)</string_value>
          <depends>
            <string_value lines="1">Temperature</string_value>
          </depends>
        </algorithm>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <particles>
          <exclude_from_particles/>
        </particles>
      </diagnostic>
    </tensor_field>
  </material_phase>
  <material_phase name="Crust">
    <equation_of_state>
      <fluids>
        <linear>
          <reference_density>
            <real_value rank="0">2900</real_value>
          </reference_density>
          <temperature_dependency>
            <reference_temperature>
              <real_value rank="0">290</real_value>
            </reference_temperature>
            <thermal_expansion_coefficient>
              <real_value rank="0">3e-5</real_value>
            </thermal_expansion_coefficient>
          </temperature_dependency>
        </linear>
      </fluids>
    </equation_of_state>
    <vector_field rank="1" name="Velocity">
      <aliased material_phase_name="EverythingExcept" field_name="Velocity"/>
    </vector_field>
    <scalar_field rank="0" name="MaterialVolumeFraction">
      <prognostic>
        <mesh name="CoordinateMesh"/>
        <equation name="AdvectionDiffusion"/>
        <spatial_discretisation>
          <control_volumes>
            <face_value name="HyperC">
              <project_upwind_value_from_point>
                <bound_projected_value_locally/>
                <store_upwind_elements/>
              </project_upwind_value_from_point>
              <courant_number name="ControlVolumeCFLNumber"/>
            </face_value>
            <diffusion_scheme name="ElementGradient"/>
          </control_volumes>
          <conservative_advection>
            <real_value rank="0">0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">0</real_value>
          </theta>
          <control_volumes>
            <maximum_courant_number_per_subcycle>
              <real_value rank="0">0.5</real_value>
              <courant_number name="ControlVolumeCFLNumber"/>
            </maximum_courant_number_per_subcycle>
            <pivot_theta>
              <real_value rank="0">0</real_value>
            </pivot_theta>
          </control_volumes>
        </temporal_discretisation>
        <explicit/>
        <initial_condition name="WholeMesh">
          <python>
            <string_value type="code" language="python" lines="20">def val(X, t):
    from Constants import conDepth, domainDim, stepLoc, stepWidth

    if X[0] &lt; stepLoc[0] or X[0] &gt; stepLoc[1]:
        return 0.
    elif X[1] &gt;= 9.59e5:
        return 1.
    else:
        return 0.</string_value>
          </python>
        </initial_condition>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <particles>
          <exclude_from_particles/>
        </particles>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <galerkin_projection>
          <continuous>
            <bounded name="Diffuse">
              <boundedness_iterations>
                <integer_value rank="0">1000</integer_value>
                <tolerance>
                  <real_value rank="0">1e-7</real_value>
                </tolerance>
              </boundedness_iterations>
              <bounds>
                <upper_bound>
                  <real_value rank="0">1</real_value>
                  <coupled/>
                </upper_bound>
                <lower_bound>
                  <real_value rank="0">0</real_value>
                </lower_bound>
              </bounds>
              <repair_deviations>
                <tolerance>
                  <real_value rank="0">1e-6</real_value>
                </tolerance>
              </repair_deviations>
            </bounded>
            <solver>
              <iterative_method name="fgmres"/>
              <preconditioner name="gamg"/>
              <relative_error>
                <real_value rank="0">1e-7</real_value>
              </relative_error>
              <max_iterations>
                <integer_value rank="0">1000</integer_value>
              </max_iterations>
              <never_ignore_solver_failures/>
              <diagnostics>
                <monitors/>
              </diagnostics>
            </solver>
          </continuous>
        </galerkin_projection>
        <priority>
          <integer_value rank="0">100</integer_value>
        </priority>
        <cap_values>
          <upper_cap>
            <real_value rank="0">1</real_value>
          </upper_cap>
          <lower_cap>
            <real_value rank="0">0</real_value>
          </lower_cap>
        </cap_values>
      </prognostic>
    </scalar_field>
    <scalar_field rank="0" name="Temperature">
      <aliased material_phase_name="EverythingExcept" field_name="Temperature"/>
    </scalar_field>
    <tensor_field rank="2" name="MaterialViscosity">
      <diagnostic>
        <mesh name="CoordinateMesh"/>
        <algorithm name="tensor_python_diagnostic" material_phase_support="single">
          <string_value type="code" language="python" lines="20">from numpy import clip, empty, exp
from Constants import a0, a1, a2, adGra, domainDim, e0, e1, e2, g, lowMtl, muMax, muMin, R, r0, r1, r2, rhoCrust, v0, v1, v2

Temp = state.scalar_fields["Temperature"]
X = state.vector_fields["Coordinate"]

assert(Temp.node_count == field.node_count)
assert(X.node_count == field.node_count)

visc = empty((2, 2))

for i in range(field.node_count):
    depth = clip(domainDim[1] - X.node_val(i)[1], 0, domainDim[1])
    pres = rhoCrust * g * depth
    adTemp = Temp.node_val(i) + adGra * depth
    if depth &lt; lowMtl:
        water = 800
        mu = 1 / (a0 * water ** r0 * exp(-(e0 + pres * v0) / R / adTemp) + a1 * water ** r1 * exp(-(e1 + pres * v1) / R / adTemp))
    else:
        water = 200
        mu = 1 / (a2 * water ** r2 * exp(-(e2 + pres * v2) / R / adTemp) + a2 * water ** r2 * exp(-(e2 + pres * v2) / R / adTemp))
    mu = clip(mu, muMin, muMax)
    visc[:] = mu
    field.set(i, visc)</string_value>
          <depends>
            <string_value lines="1">Temperature</string_value>
          </depends>
        </algorithm>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <particles>
          <exclude_from_particles/>
        </particles>
      </diagnostic>
    </tensor_field>
  </material_phase>
  <mesh_adaptivity>
    <hr_adaptivity>
      <period_in_timesteps>
        <integer_value rank="0">10</integer_value>
      </period_in_timesteps>
      <maximum_number_of_nodes>
        <integer_value rank="0">100000</integer_value>
      </maximum_number_of_nodes>
      <enable_gradation>
        <gradation_parameter>
          <real_value rank="0">1.2</real_value>
        </gradation_parameter>
      </enable_gradation>
      <metric_advection>
        <spatial_discretisation>
          <control_volumes>
            <face_value name="FirstOrderUpwind"/>
          </control_volumes>
          <conservative_advection>
            <real_value rank="0">0</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">0</real_value>
          </theta>
          <maximum_courant_number_per_subcycle>
            <real_value rank="0">0.5</real_value>
            <courant_number name="ControlVolumeCFLNumber"/>
          </maximum_courant_number_per_subcycle>
          <scale_advection_time>
            <real_value rank="0">3</real_value>
          </scale_advection_time>
          <control_volumes/>
        </temporal_discretisation>
        <explicit/>
        <output/>
      </metric_advection>
      <tensor_field name="MinimumEdgeLengths">
        <anisotropic_symmetric>
          <constant>
            <real_value symmetric="true" rank="2" dim1="dim" dim2="dim" shape="2 2">5e3 0 0 5e3</real_value>
          </constant>
        </anisotropic_symmetric>
      </tensor_field>
      <tensor_field name="MaximumEdgeLengths">
        <anisotropic_symmetric>
          <constant>
            <real_value symmetric="true" rank="2" dim1="dim" dim2="dim" shape="2 2">2e5 0 0 2e5</real_value>
          </constant>
        </anisotropic_symmetric>
      </tensor_field>
      <aspect_ratio_bound>
        <real_value rank="0">10</real_value>
      </aspect_ratio_bound>
      <adapt_at_first_timestep>
        <number_of_adapts>
          <integer_value rank="0">5</integer_value>
        </number_of_adapts>
      </adapt_at_first_timestep>
      <zoltan_options>
        <partitioner>
          <scotch/>
        </partitioner>
        <final_partitioner>
          <scotch/>
        </final_partitioner>
        <load_balancing_approach>
          <partition/>
        </load_balancing_approach>
        <element_quality_cutoff>
          <real_value rank="0">0.6</real_value>
        </element_quality_cutoff>
        <load_imbalance_tolerance>
          <real_value rank="0">1.25</real_value>
        </load_imbalance_tolerance>
        <additional_adapt_iterations>
          <integer_value rank="0">5</integer_value>
        </additional_adapt_iterations>
      </zoltan_options>
      <adaptivity_library>
        <libmba2d>
          <quality>
            <real_value rank="0">0.6</real_value>
          </quality>
        </libmba2d>
      </adaptivity_library>
      <adapt_iterations>
        <integer_value rank="0">5</integer_value>
      </adapt_iterations>
    </hr_adaptivity>
  </mesh_adaptivity>
  <flredecomp>
    <final_partitioner>
      <scotch/>
    </final_partitioner>
  </flredecomp>
</fluidity_options>
